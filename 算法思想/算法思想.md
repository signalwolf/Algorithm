
# 我在想，常见的算法的思想有什么？

### Binary search:
二分法就是在尝试找到一个条件，能够将当前的数组丢掉一半。这样我们每次丢掉一半的话，那么处理本来
size 为 n 的数据便只需要 logn了

典型问题：就是在sorted的array中找某个数是否存在
1.  左右指针，求中间指针，如果比中间指针大，那么表明左边的都可以丢弃。故而left = mid
2.  反之比中间指针小，右边可以丢弃，right = mid；

关键词：丢一半

### Divide and conquer:
分治法就是将问题分解为多个小问题，当问题足够小的时候直接解决问题。然后在叠起来解决更大的问题。

典型问题：tree sum，
1.  当前tree的sum == 左子树的sum + 右子树的sum。
2.  当问题逐渐变小到leaf node 的时候，可以直接解决了，当前leaf node的 sum of tree = node.val

关键词：分而治之 + 最小情况（出口）
1.  怎么缩小问题
2.  什么是足够小的问题
3.  怎么解决这个足够小的问题
4.  怎么合并更小问题的解而得到当前问题的解

判断使用：
1.  当问题足够小的时候是否能够直接解决
2.  问题能够分解为多个子问题，且这些子问题具有最优子结构性质 （如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。）
当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。
3.  由子问题得到的解能够合并并且成为当前问题的解 --》 如果不能合并那么就一定不能用分治法
4.  子问题间不重复，如果重复，考虑使用dp来解决问题。
    

### DP：
DP 想法的本质也是将问题缩小到足够小的问题。但是在缩小问题的过程中会发现有重复计算的情况。故而通过使用
memory的方式方法来记住曾经计算过的情况，这样速度便大幅度的提升了。

关于bottom up的方法，其思想稍有不同，它每次决策的时候依赖于当前的状态，然后决策后又引起状态的转移，由此形成了一个决策序列

DP有两种算法：
1.  一种是按照上面说的 top down的方法，就是将问题缩小化后存在memory中，并由此加速问题。
2.  另一种则是反过来的，bottom up的方法，就是我们先解决小的问题然后再向上推导。
    

判断使用（bottom up）
1.  最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。
当一个问题的最优解包含着它的子问题的最优解时，就称此问题具有最优子结构性质。
2.  无后效性：当前问题的解只与之前的解有关而与之后的解完全没有关系
3.  重叠问题：子问题之间有重叠，一个子问题可能在下面的决策中多次的使用。该状态并不为必要条件，但是如果没有它的话会造成效率与其他算法比没有优势

典型问题：爬楼梯

使用关键词：重复
1. 有没有重复的计算，如果很多，就用memory来记住它。

实现关键字：
1. State: DP[i] 代表什么，表示的是什么样的状态 --> 状态与状态变量
2. Function: DP[i] 与 DP[i - k] 们的关系 --》 转移方程
3. Initial: DP[0] 的情况是怎么样的 --》边界条件
4. Answer: 返回值是什么？DP[n] ?

### 贪心算法 （Greedy）
所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。
贪心算法也需要满足无后效性

贪心算法适用的情况很少

贪心算法的基本思路：
1.  建立数学模型来描述问题。
2.  把求解的问题分成若干个子问题。
3.  对每一子问题求解，得到子问题的局部最优解。
4.  把子问题的解局部最优解合成原来解问题的一个解。

使用贪心算法前一定要非常谨慎的对问题进行深入且透彻的分析与证明，以确保贪心法能够得到最优解


### 回溯法 （DFS）

往往是使用DFS来尝试解决一些问题，当发现当前的node下面不可能有满足条件的情况的时候就向回走一步（回溯/剪枝）

在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。
若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。
而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。

### 分支限界法 （BFS）

回溯法尝试解决的是所有的解（然后找出最优解），然而分支限界法则是找到满足条件的一个解就stop

与回溯法不同的是，它采用的BFS。但是BFS也有三种的处理方式：stack （FILO）或者 queue（FIFO）或者 PQ

分支限界法往往是找到最小消耗的解。

### 穷举法/暴力法 （brute force）

根据题目的部分条件确定范围，并在次范围内对所有情况逐一穷尽验证，直到找到那个最符合的解。
